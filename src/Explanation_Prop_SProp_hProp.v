(** * Prop, SProp and hProp

  *** Summary

  An explanation of the differences and subtleties of Prop, SProp and hProp

  *** Contents
  - 1. Prop
  - 2. hProp
  - 3. SProp
  - 4. Vec
*)

(*    | imprediativity | unicity of proofs | elimination
Prop  | Yes            | Axiom             | False, eq, Acc (sub-singleton)
SProp | Yes            | Strict            | False
hProp | Axiom          | Yes               |

*)

(** * 1.Prop
  Prop is meant for extraction.
  When a program is coded in rocq to acertain its properties,
  It needs to be extracted to be used.
  Data carried around for proofs are not necessarily needed for its execution,
  and, in that case, Prop can be used.

  Prop is a sort, meaning elements can appear on the right side of ":"
  *)

Parameter P : Prop.
Parameter p : P.

(** You can also form elements through inductive definition *)

Inductive and (A B : Prop) : Prop :=
  | conj : A -> B -> and A B.
  
(** [P] is erased at extraction, or is reduced to unit *)
(** Prop is impredicative, a property that Type doesn't share *)

Parameter A : Type.
Parameter B : A -> Prop.

Check (forall a : A, B a) : Prop. (* Only the sort of the codomain matter *)

Universe i j.
Constraint i < j.
Parameter C : Type@{j}.
Parameter T : C -> Type@{i}.

Fail Check (forall c: C, T c) : Type@{i}.

(** A function of [forall a : A, B a] serves no purpose after extraction,
  it can at best produces elements of unit, as such it is put in [Prop] as well *)

(** The last property of [Prop] is sub-singleton elimination
  In principle, a sort can only be eliminated in itself,
  that is, for an inductive [I] defined in a sort [T],
  a pattern matching on [I] will only work to create a term in a type of sort [T].
  However Rocq implements large elimination, meaning types can be eliminated in all sorts,
  and singleton elimination, meaning if an inductive in [Prop] has "less than one" constructor,
  it can be eliminated in [Type]. *)
(** What an inductive definition eliminates into is also made visible
  through the induction principles generated by rocq,
  [I_rec] and [I_recT] only exists if it eliminates *)

Inductive ex_singleton0 : Prop :=. (* having no constructor is few enough *)
Print ex_singleton0_rect.

Inductive ex_singleton1 : Prop :=
  | cons1 : ex_singleton1. (* having a single one as well *)

Inductive ex_not_singleton0 : Prop :=
  | cons00 : ex_not_singleton0
  | cons01 : ex_not_singleton0.  (* having two constructors is too much *)
Fail Print ex_not_singleton0_rect.

Inductive ex_not_singleton1 : Prop :=
  | cons10 : bool -> ex_not_singleton1. (* so is it the case when they are package up as one *)

Inductive ex_not_singleton2 : Prop :=
  | cons20 : unit -> ex_not_singleton2.

 (* An type as an argument to the constructor is forbidden,
  even if it only has one constructor *)

Inductive ex_singleton2 : Prop :=
  | cons2 : P -> ex_singleton2. (* A Prop is fine however *)

Inductive ex_singleton3 {S : SProp} : Prop :=
  | cons3 : S -> ex_singleton3. (* So is a SProp *)

Inductive ex_singleton4 {S : SProp} : Prop :=
  | cons4 : P -> S -> ex_singleton4 -> ex_singleton4. (* And so is this *)

(** Note that Prop also eliminates in SProp in all cases *)

(** The equality type [eq], as well as the accessibility predicate [Acc] are in [Prop],
  the [ex] type, which uses the [exists x. P x] binders, also is *)



(** * 2. hProp 
  Being an hProp, homotopic proposition or mere proposition,
  is defined internally through a predicate, usually as follows *)

Definition ishProp A := forall x y : A, x = y.

Definition hProp := { A : Type | ishProp A }.

(** A notable exemple is the singleton type (no relation to subsingleton elimination) *)

Definition singleton_type A (x : A) : Type := {y : A | x = y }.

Definition singleton_coh : forall A x, ishProp (singleton_type A x):= fun A x y y'=>
  match y, y' with
  | exist _ _ hy, exist _ _ hy' =>
    match hy, hy' with
    | eq_refl, eq_refl => eq_refl end
  end.

Definition singleton A (x : A) : hProp := exist ishProp (singleton_type A x) (singleton_coh A x).

(** 3. SProp
  SProp is a sort of type with externally a single element *)

Inductive Seq (S : SProp) (s : S) : S -> Prop :=
  | Seq_refl  : Seq S s s.
  (* Since SProp doesn't coerce to Type, we use a separate equality inductive *)

Arguments Seq_refl {_ _}.
Parameter SP : SProp.
Parameter s s' : SP.

Check Seq_refl : Seq SP s s'.

Parameter p' : P. (* from our earlier Prop *)

Fail Check eq_refl : eq P p p'.

(** Reflexivity is not a proof of equality of proofs of a proposition,
 while it is for proofs of a strict proposition.
 In general, the former have no proof of equality at all,
 and while equality can always be shown for homotopic proposition,
 the proof is not usually reflexivity *)

(** You can still form elements through inductive definition *)

Inductive sand (A B : SProp) : SProp :=
  | sconj : A -> B -> sand A B.

(** SProp also has a form of singleton elimination *)

Inductive ex_Ssingleton : SProp :=. (* This is the only case in Rocq *)
Print ex_Ssingleton_rect.

(** SProp also enjoys imprediactivity *)

Parameter SB : A -> SProp. (* the A from impredicativity of Prop *)

Check (forall a : A, SB a) : SProp. (* Only the sort of the codomain matter *)

(** 4. Vec 
  We will compare some definitions of Vec to showcase the difference uin definition *)

Inductive Vec A : nat -> Type:=
  | Vec_nil : Vec A 0
  | Vec_cons n : A -> Vec A n -> Vec A (S n).

Definition app {A n m}: Vec A n -> Vec A m -> Vec A (n+m).
Proof.
  intros v w. induction v as [ | n a v vapp].
  + apply w.
  + apply (Vec_cons _ (n + m) a vapp).
Defined.

Definition VecP A n := { l : list A | length l = n}.

Inductive SBox A : SProp :=
  | Sbox (a : A) : SBox A.

Inductive SigS A (B : A -> SProp) : Type :=
  | existS (a : A) (b : B a): SigS A B.

Definition VecS A n := SigS (list A) (fun l => SBox (length l = n)).

(** Say we want to extract the list and dismiss the length *)

Definition Vec_to_list A n : Vec A n -> list A.
Proof.
  intros v.
  induction v as [ | n a v l].
  + apply nil.
  + apply (cons a l).
Defined.

Definition VecP_to_list A n : VecP A n -> list A :=
  proj1_sig (P:=fun l : list A => length l = n).

Definition VecS_to_list A n : VecS A n -> list A := fun '(existS _ _ l _) => l.

(** A Vector's data is limited to its elements in order,
  we will sketch proof for each definitions *)

Definition Vec_nil_inv : forall A P, P (Vec_nil A) ->
  forall v : Vec A 0, P v :=
    fun A P hP v =>
    match v as v' in Vec _ n return
      (match n with 0 => P | _ => (fun _ => True) end) v'
      with | Vec_nil _ => hP | _ => I end.

Definition Vec_cons_inv : forall A P, (forall n a v, P n (Vec_cons A n a v)) ->
  forall n (v : Vec A (S n)), P n v :=
    (fun A P hP n v => match v as v' in Vec _ m return
      (match m with | S m' => P m' | 0 => (fun _ => True) end) v'
      with | Vec_nil _ => I | Vec_cons _ n a v  => hP n a v end).

Goal forall A n v v', Vec_to_list A n v = Vec_to_list A n v' -> v = v'.
Proof.
  intros A n v.
  induction v.
  + intros v' _.
    pattern v'.
    apply Vec_nil_inv.
    reflexivity.
  + intros v'. revert v IHv.
    pattern v'.
    apply Vec_cons_inv with (n:=n) (A:=A) (v:=v').
    clear.
    intros n a' v v' IHv Heq. simpl in Heq.
    inversion Heq.
    destruct H0.
    f_equal.
    apply IHv.
    apply H1. Show Proof.
Defined.


From Stdlib Require Import Eqdep_dec.

Check UIP_refl_nat : forall (n : nat) (x : n = n), x = eq_refl.
(* We import this result from the standard library *)
Print Assumptions UIP_refl_nat. (* No hidden axioms *)

Goal forall A n v v', VecP_to_list A n v = VecP_to_list A n v' -> v = v'.
Proof.
  intros A n [l hl] [l' hl']. cbn.
  intros <-.
  f_equal.
  destruct hl'.
  apply UIP_refl_nat.
Defined.

Goal forall A n v v', VecS_to_list A n v = VecS_to_list A n v' -> v = v'.
Proof.
  intros A n [l hl] [l' hl']. cbn.
  intros <-.
  reflexivity.
Defined.

(** The first definition [Vec], is cumbersome to use, [VecP] is much easier,
  but only because are well behaved and known to be. [VecS] was straightforward,
  and the principle would scale better *)
